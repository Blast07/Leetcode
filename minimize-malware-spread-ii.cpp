//928


int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
	int n  = graph.size();

	vector <int> count(n, 0);
	vector <int> labels(n, 0);
	//0 not visited or infected
	//-1 infected initially
	// i>=1 infected by some other node i-1
    for (int i:initial)
        labels[i] =-1;

	for (int i:initial){
		queue <int> q;
		q.push(i);
    
        count[i]++;
		while(!q.empty()){
            
			int front = q.front(); q.pop();

			for (int j=0;j<n;j++){
				if(j == front || labels[j] == -1 || (labels[j] == i+1))
					continue;
                if (graph[front][j]){
				    if (labels[j] == 0){
					    labels[j] = i+1; //making it infected by ith node
					    q.push(j);
                        count[i]++;
				    }else{ //already infected by some node
					    count[labels[j]-1]--;
					    labels[j] = -1;
                        q.push(j);
				    }
                }
			}
		}
	}
	int max_inf = 0;
	int res;
	for (int i=0;i<n;i++){
    
		if (count[i] > max_inf){
			res =i;
			max_inf = count[i];
		}
	}
	return res;
}

/*
Bruteforce - accepted but slow

int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
	sort(initial.begin(), initial.end());    
	int res;
	int min_inf = INT_MAX;


	for (int i:initial){
		queue <int> q;
		vector <bool> visited(graph.size(), false);

		for (int x:initial){
			if (x != i){
				q.push(x);
				visited[x] = true;
			}
		}

		int total = 0;	

		while(!q.empty()){
			int front = q.front(); q.pop();
			total++;

			for (int j=0;j<graph.size();j++){
				if (j == i)
					continue;
				if (!visited[j] && graph[front][j]){
					q.push(j);
					visited[j] = true;
				}
			}

		}
		if (totoal < min_inf){
			min_inf = total;
			res = i;
		}

	}
	return res;
}
*/
